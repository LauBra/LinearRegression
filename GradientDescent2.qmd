
```{r}
#| message: false
library(tidyverse)
library(plot3D)
```


# (4) Gradient Descent

Gradient descent is a foundational **optimization** technique widely used in machine learning to find the **minimum** of a function. [The core idea is to iteratively adjust variables in the opposite direction of the gradient (slope) to minimize the function’s output]{style="color:blue;"}.

## The Gradient Descent Formula

The general update formula for gradient descent is:

$$
x_{n+1} = x_n - \alpha f'(x_n) 
$$

where:

-   $x_n$ is the current guess
-   $f'(x_n)$ is the gradient at $x_n$
-   $\alpha$ is the learning rate (a small positive constant that controls the step size)

The idea is that the steeper the slope, the larger the update, moving us closer to the minimum.

## Single-Variable Gradient Descent

Let’s replicate the slides seen in class and minimize a single-variable function, $f(x) = x^2$. Imagine we start with an initial guess that the minimum is at $x = -4$ (although we know this is not the true minimum, from class we have seen this happens at $x = 0$). We will iteratively improve this guess by calculating the derivative (gradient) and adjusting the guess.

### Understanding the Derivative's Role

In gradient descent, the derivative (or gradient) tells us the slope of the function at any given point. Here’s the intuition:

-   *If the derivative is positive*: The function is sloping upwards, so we should move "downhill" by decreasing our guess.

-   *If the derivative is negative*: The function is sloping downwards, so we should move "downhill" by increasing our guess.

This approach ensures that we move towards the minimum at each step.

### Example: Minimizing $f(x) = x^2$

Using function $f(x) = x^2$, first we have to calculate the derivative of this function $f'(x) = 2x$

```{r}
#Define the function and its derivative 

f <- function(x) {
  
  x^2
}

f_prime <- function(x) {
  
  2* x
  
}
```

This is how they look:

```{r}

library(ggplot2)
# Create a sequence of x values
x_vals <- seq(-10, 10, length.out = 100)

# Compute y values for both functions
data <- data.frame(
  x = x_vals,
  f_x = f(x_vals),
  f_prime_x = f_prime(x_vals)
)

head(data)

library(patchwork)

A <- ggplot(data, aes(x = x)) +
  geom_line(aes(y = f_x, color = "f(x) = x^2"), size = 1) +
  #geom_line(aes(y = f_prime_x, color = "f'(x) = 2x"), size = 1) +
  labs(title = "Plot of f(x) = x^2 ",
       x = "x",
       y = "f(x)") +
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  scale_color_manual("", values = c("f(x) = x^2" = "blue", "f'(x) = 2x" = "red")) +
  theme_minimal()

B <- ggplot(data, aes(x = x)) +
  #geom_line(aes(y = f_x, color = "f(x) = x^2"), size = 1) +
  geom_line(aes(y = f_prime_x, color = "f'(x) = 2x"), size = 1) +
  labs(title = "Plot of  f'(x) = 2x",
       x = "x",
       y = "f'(x)") +
  ylim(-20, 100) +  
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  scale_color_manual("", values = c("f(x) = x^2" = "blue", "f'(x) = 2x" = "red")) +
  theme_minimal()

A + B

```

```{r}
# Set initial values

alpha <- 0.8 # Learning rate 
x <- -10 # Initial guess
x_store <- NULL
```

As previosuly explained, the general update formula for gradient descent is:

$$
x_{n+1} = x_n - \alpha f'(x_n) 
$$

As you can see, this code iteratively adjusts our guess $x$ based on the gradient at each step, converging towards the minimum. To find the minimum of a function, gradient descent updates the current guess x_n by a step that depends on the gradient (slope) at x_n.

```{r}
# Gradient descent loop

for (i in 1:10) { 
  
  gradient <- f_prime(x) 
  
  
  # Update parameters
  x <- x - alpha * gradient

  # Store values for plotting
  x_store[i] <- x
  
  cat("Step", i, ": x =", x, "f(x) =", f(x), "\n") 
  
  }
```

This code iteratively adjusts $x$ based on the gradient at each step, converging towards the minimum of f(x).

Plotting it all together

```{r}

Approximations <- data.frame(x = x_store, y = f(x_store), dy = f_prime(x_store)) %>%
  add_rownames()# Assign a "darkening" group

Approximations$rowname <- as.numeric(Approximations$rowname )

A <- ggplot(data, aes(x = x)) +
  geom_line(aes(y = f_x), color = "blue", size = 1) +
  labs(title = "Plot of f(x) = x^2 ",
       x = "x",
       y = "f(x)") +
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  geom_point(data = Approximations, aes(x = x, y = y, fill = rowname), size = 3,pch=21,colour = "black", show.legend = FALSE) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = NA) +
  theme_minimal()

B <- ggplot(data, aes(x = x)) +
  geom_line(aes(y = f_prime_x),  color = "blue", size = 1) +
  labs(title = "Plot of  f'(x) = 2x",
       x = "x",
       y = "f'(x)") +
  ylim(-20, 100) +  
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  geom_point(data = Approximations, aes(x = x, y = dy, fill = rowname), size = 3,pch=21,colour = "black", show.legend = FALSE) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = NA) +
  theme_minimal()

A + B


```

::: callout-note
## Note

A larger learning rate $\alpha$ can make the steps too large, causing the algorithm to "overshoot" the minimum, while a smaller learning rate may result in slow convergence.
:::

## Your turn! 

Use gradient descent to minimize the following functions. For each function, start with different initial guesses and observe how the algorithm converges to a minimum.

$$
f(x) = x^2 + 3x + 5
$$

```{r}
# Define the function and its derivative 

f <- function(x) {
  x^2 + 3*x + 5
  
}
  
f_prime <- function(x) {
  
  2*x + 3
  
}
```

Why not plot it?

```{r}

# Create a sequence of x values
x_vals <- seq(-15, 15, length.out = 100)

# Compute y values for both functions
data <- data.frame(
  x = x_vals,
  f_x = f(x_vals),
  f_prime_x = f_prime(x_vals)
)

head(data)

library(patchwork)

A <- ggplot(data, aes(x = x)) +
  geom_line(aes(y = f_x, color = "f(x) =  x^2 + 3*x + 5"), size = 1) +
  #geom_line(aes(y = f_prime_x, color = "f'(x) = 2x + 1"), size = 1) +
  labs(title = "Plot of f(x) =  x^2 + 3*x + 5",
       x = "x",
       y = "f(x)") +
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  scale_color_manual("", values = c("f(x) =  x^2 + 3*x + 5" = "blue")) +
  theme_minimal()

B <- ggplot(data, aes(x = x)) +
  #geom_line(aes(y = f_x, color = "f(x) = x^2"), size = 1) +
  geom_line(aes(y = f_prime_x, color = "f'(x) = 2*x + 3"), size = 1) +
  labs(title = "Plot of  f'(x) = 2*x + 3",
       x = "x",
       y = "f'(x)") +
  ylim(-30, 100) +  
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  scale_color_manual("", values = c( "f'(x) = 2*x + 3" = "red")) +
  theme_minimal()

A + B
```

```{r}
# Parameters

alpha <- 0.01 
x <- 2 # Initial guess
```

```{r}
# Gradient descent loop

for (i in 1:10) { 
  
  x <- x - alpha * f_prime(x) 
  
  cat("Step", i, ": x =", x, "f(x) =", f(x), "\n") 
  
  }
```

## Part 3: Local vs Global Minima

Gradient descent may not always reach the global minimum, especially if the function has multiple minima. The algorithm might "get stuck" in a local minimum, particularly if the initial guess is close to one of these minimum.

Consider the function $f(x) = x^4 + x^3 - 2x^2$, which has both local and global minima.

```{r}
f <- function(x) {
  
  x^4 + x^3 - 2*(x^2) 
}
  
f_prime <- function(x){
  
  4*(x^3) + 3*(x^2) - 4*x
}
```

Parameters

```{r}
alpha <- 0.01 
x <- 1
x_store <- NULL
```

```{r}
for (i in 1:10) { 
  
  
  x <- x - alpha *f_prime(x) 
  
  x_store[i] <- x
  
  cat("Step", i, ": x =", x, "f(x) =", f(x), "\n") 
  
}
```

```{r}

Approximations <- data.frame(x = x_store, y = f(x_store), dy = f_prime(x_store)) %>%
  add_rownames()# Assign a "darkening" group)

Approximations$rowname <- as.numeric(Approximations$rowname )

# Create a sequence of x values
x_vals <- seq(-15, 15, length.out = 100)

# Compute y values for both functions
data <- data.frame(
  x = x_vals,
  f_x = f(x_vals),
  f_prime_x = f_prime(x_vals)
)

head(data)

A_big <- ggplot(data, aes(x = x)) +
  geom_line(aes(y = f_x), color = "blue", size = 1) +
  labs(title = "Plot of f(x) = x^4 + x^3 - 2*x^2  ",
       x = "x",
       y = "f(x)") +
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  geom_point(data = Approximations, aes(x = x, y = y, fill = rowname), size = 3,pch=21,colour = "black", show.legend = FALSE) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = NA) +
  theme_minimal()


# Create a sequence of x values
x_vals <- seq(-5, 5, length.out = 100)

# Compute y values for both functions
data <- data.frame(
  x = x_vals,
  f_x = f(x_vals),
  f_prime_x = f_prime(x_vals)
)

head(data)

A <- ggplot(data, aes(x = x)) +
  geom_line(aes(y = f_x), color = "blue", size = 1) +
  labs(title = "Plot of f(x) = x^4 + x^3 - 2*x^2  ",
       x = "x",
       y = "f(x)") +
   ylim(-5, 5) +  
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  geom_point(data = Approximations, aes(x = x, y = y, fill = rowname), size = 3,pch=21,colour = "black", show.legend = FALSE) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = NA) +
  theme_minimal()

B <- ggplot(data, aes(x = x)) +
  geom_line(aes(y = f_prime_x),  color = "blue", size = 1) +
  labs(title = "Plot of  f'(x) = 4*x^3 + 3*x^2 - 4*x",
       x = "x",
       y = "f'(x)") +
  ylim(-20, 90) +  
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  geom_point(data = Approximations, aes(x = x, y = dy, fill = rowname), size = 3,pch=21,colour = "black", show.legend = FALSE) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = NA) +
  theme_minimal()

(A_big | A) 

(A | B )
```

We see this function has 2 minimums! One is a local minimim and the other the global minimum. Depending on where we start (intialization point) we will end up in one or the other.

Exercise! Try different initial guesses, record which initial guess leads to global minimum.

Parameters

```{r}
alpha <- 0.03
x <- -0.5
x_store <- NULL
number_iterations <- 100
```

```{r}
for (i in 1:number_iterations) { 
  
  
  x <- x - alpha *f_prime(x) 
  
  x_store[i] <- x
  
  cat("Step", i, ": x =", x, "f(x) =", f(x), "\n") 
  
}
```

```{r}



Approximations <- data.frame(x = x_store, y = f(x_store), dy = f_prime(x_store)) %>%
  add_rownames()# Assign a "darkening" group)

Approximations$rowname <- as.numeric(Approximations$rowname )

# Create a sequence of x values
x_vals <- seq(-15, 15, length.out = 100)

# Compute y values for both functions
data <- data.frame(
  x = x_vals,
  f_x = f(x_vals),
  f_prime_x = f_prime(x_vals)
)

head(data)

A_big <- ggplot(data, aes(x = x)) +
  geom_line(aes(y = f_x), color = "blue", size = 1) +
  labs(title = "Plot of f(x) = x^4 + x^3 - 2*x^2  ",
       x = "x",
       y = "f(x)") +
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  geom_point(data = Approximations, aes(x = x, y = y, fill = rowname), size = 3,pch=21,colour = "black", show.legend = FALSE) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = NA) +
  theme_minimal()


# Create a sequence of x values
x_vals <- seq(-5, 5, length.out = 100)

# Compute y values for both functions
data <- data.frame(
  x = x_vals,
  f_x = f(x_vals),
  f_prime_x = f_prime(x_vals)
)

head(data)

A <- ggplot(data, aes(x = x)) +
  geom_line(aes(y = f_x), color = "blue", size = 1) +
  labs(title = "Plot of f(x) = x^4 + x^3 - 2*x^2  ",
       x = "x",
       y = "f(x)") +
   ylim(-5, 5) +  
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  geom_point(data = Approximations, aes(x = x, y = y, fill = rowname), size = 3,pch=21,colour = "black", show.legend = FALSE) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = NA) +
  theme_minimal()

B <- ggplot(data, aes(x = x)) +
  geom_line(aes(y = f_prime_x),  color = "blue", size = 1) +
  labs(title = "Plot of  f'(x) = 4*x^3 + 3*x^2 - 4*x",
       x = "x",
       y = "f'(x)") +
  ylim(-20, 90) +  
  geom_hline(yintercept = 0, color = "black") +  # Add horizontal line at y = 0
  geom_vline(xintercept = 0, color = "black") +
  geom_point(data = Approximations, aes(x = x, y = dy, fill = rowname), size = 3,pch=21,colour = "black", show.legend = FALSE) +
  scale_fill_gradient(low = "yellow", high = "red", na.value = NA) +
  theme_minimal()

(A_big | A) 

(A | B )
```

What happens at initial point x = 0? And if you increase the learning rate a lot? Does it mean it gets to the minimum faster? But which one? What is another parameter you can modify?..... ITERATIONS!


```{r}
#Try out any other modification!
```


As you have seen:

The choice of learning rate $\alpha$ is crucial:

-   If $\alpha$ too large, the algorithm might oscillate and fail to converge.

-   If $\alpha$ too slow, requiring more iterations.

Example of high learning rate:

Setting $\alpha = 0.5$

## Part 4: Multivariable Gradient Descent

Multivariable gradient descent is an extension of the single-variable case. Instead of using a single derivative, we calculate the gradient vector, which consists of the partial derivatives of the function with respect to each variable.

Consider the function:

$$
f(x, y) = xsin(y) + x^2
$$

The gradient of this function is:

$$
\nabla f(x, y) = \left\langle \frac{\partial f}{\partial x}, \frac{\partial f}{\partial y} \right\rangle = \langle \sin(y) + 2x, x \cos(y) \rangle
$$

Let's apply gradient descent starting from an initial guess of $\vec{x} = (1, 2)$ with a learning rate of $\alpha = 0.01$

```{r}
# Define the function and its partial derivatives 

f <- function(x, y) {
  x* sin(y) + x^2 
}
  
f_x <- function(x, y) {
  
  sin(y) + 2*x 
  
}
  

f_y <- function(x, y){
  
  x*cos(y)

}
```

Another way to do it in R is using the function Deriv()

```{r}
library(Deriv) 


# Define the function f(x, y) = x* sin(y) + x^2

f <- function(x, y) { 
  x*sin(y) + x^2 
  }

# Compute the gradient symbolically (exact expressions)

grad_f <- Deriv(expression(x*sin(y) + x^2), c("x", "y"))

print(grad_f)
#expression(c(x = 2 * x + sin(y), y = x * cos(y))) Computes the partial derivatives for you!!!!!

gradient <- function(x, y) { 
  
  eval(grad_f) 
  }
```

As you can see is the partial derivatives above written, directly calculated

```{r}
# Initial parameters

alpha <- 0.01 # Learning rate 
iterations <- 100 # Number of iterations 
x <- 1 # Initial guess for x 
y <- 2 # Initial guess for y

# Store results for plotting

results <- data.frame(Iteration = 0, x = x, y = y, f_value = f(x, y))

# Gradient descent loop
```

```{r}

for (i in 1:iterations) { 
  
  grad <- gradient(x = x, y = y)
  
  # Evaluate gradient 
  x <- x - alpha* grad[1] 
  y <- y - alpha * grad[2] 
  results <- rbind(results, data.frame(Iteration = i, x = x, y = y, f_value = f(x, y))) 
  
 # would be the same as:
  #x <- x - alpha*f_x(x, y) 
  #y <- y - alpha* f_y(x, y) 
  
  
  }

# Display first few iterations

head(results)
```

```{r}
#Generate grid data for 3D surface plot 

x_vals <- seq(-2, 2, length.out = 50) 
y_vals <- seq(-1, 3, length.out = 50) 
z_vals <- outer(x_vals, y_vals, Vectorize(f)) #evaluate x and y values in function f

# 3D plot

persp3D(x = x_vals, y = y_vals, z = z_vals, col = "lightblue", theta = 30, phi = 20, expand = 0.6, shade = 0.5, main = "Gradient Descent Path on f(x, y) = x*sin(y) + x^2", xlab = "x", ylab = "y", zlab = "f(x, y)")

# Overlay gradient descent path

points3D(results$x, results$y, results$f_value, col = "red", pch = 19, add = TRUE)
lines3D(results$x, results$y, results$f_value, col = "red", add = TRUE)
```
As expected, the value of the function is being minimized at each iteration!

```{r}
# Plot the value of f(x, y) over iterations 

ggplot(results, aes(x = Iteration, y = f_value)) + geom_line(color = "blue") + labs( title = "Convergence of Gradient Descent on f(x, y) = x*sin(y) + x^2", x = "Iteration", y = "f(x, y)" ) + theme_minimal()

```

## Final Remarks

Gradient descent is a versatile optimization technique, but it’s not without limitations:

* It may converge to local minima rather than the global minimum. It is sensitive to the choice of learning rate and initial guess.

* Variants of gradient descent, like stochastic gradient descent (SGD) and momentum-based methods, are often used to address these issues in large-scale machine learning tasks. Understanding and experimenting with gradient descent is crucial for developing an intuition about optimization in machine learning and algorithms. 

# Try it out with our own MSE, from the previous exercises

```{r}

library(mlbench)

# Load the dataset
data("PimaIndiansDiabetes")

# Select the first 80 rows and extract the variables
data_subset <- PimaIndiansDiabetes[1:80, ]
x <- data_subset$age
y <- data_subset$glucose

```

```{r}
# Gradient descent parameters
alpha <- 0.0001  # Learning rate
iterations <- 1000  # Number of iterations
m <- -3  # Initial guess for slope
c <- 55  # Initial guess for intercept

# Lists to store m, c, and MSE values for plotting
m_path <- numeric(iterations)
c_path <- numeric(iterations)
mse_history <- numeric(iterations)

```




```{r}
# Define the MSE function
mse <- function(m, c, x, y) {
  
  y_pred <- m * x + c
  mean((y - y_pred)^2)
  
  #same thing: (1 / n) * sum((y - (m * x + c))^2)
}

# Define the gradients of MSE with respect to m and c
mse_gradient_m <- function(m, c, x, y) {
  -2 / length(y) * sum(x * (y - (m * x + c)))
}

mse_gradient_c <- function(m, c, x, y) {
  -2 / length(y) * sum(y - (m * x + c))
}

#Remember can also apply the Deriv function 

grad_f <- Deriv(expression((1 / n)* sum((y - (m * x + c))^2)), c("m", "c"))

print(grad_f)
    
    
```
Unsure where the derivatives come from or how to calculate them?Go to the OLS_Derivation exercise. 

Now, lets perform gradient descent: 
```{r}
# Perform gradient descent
for (i in 1:iterations) {
  # Compute gradients
  grad_m <- mse_gradient_m(m, c, x, y)
  grad_c <- mse_gradient_c(m, c, x, y)
  
  # Update parameters
  m <- m - alpha * grad_m
  c <- c - alpha * grad_c
  
  # Store values for plotting
  m_path[i] <- m
  c_path[i] <- c
  mse_history[i] <- mse(m, c, x, y)
  
  # Print progress every 100 iterations
  if (i %% 100 == 0) {
    cat("Iteration:", i, "Slope (m):", m, "Intercept (c):", c, "MSE:", mse_history[i], "\n")
  }
}

```

Optimized parameters:

```{r}

paste0("Slope:" ,m)
paste0("Slope:" ,c)
```


```{r}
# Plot the data points and the fitted line
ggplot(data_subset, aes(x = age, y = glucose)) +
  geom_point() +
  geom_abline(intercept = c, slope = m, color = "blue", size = 1) +
  labs(title = "Linear Fit using Gradient Descent", x = "Age", y = "Glucose") +
  theme_minimal()

# Plot MSE over iterations
mse_df <- data.frame(iteration = 1:iterations, MSE = mse_history)
ggplot(mse_df, aes(x = iteration, y = MSE)) +
  geom_line(color = "red") +
  labs(title = "MSE over Iterations", x = "Iteration", y = "Mean Squared Error") +
  theme_minimal()

```

```{r}
# Create a grid of values for m and c
m_values <- seq(-5, 5, length.out = 50)
c_values <- seq(0, 200, length.out = 50)

# Initialize a matrix to store MSE values
mse_matrix <- outer(m_values, c_values, Vectorize(function(m, c) mse(m, c, x, y)))

# Plot the MSE surface
persp3D(x = m_values, y = c_values, z = mse_matrix, 
        theta = 45, phi = 0, 
        xlab = "Slope (m)", ylab = "Intercept (c)", zlab = "MSE",
        main = "MSE Surface with Gradient Descent Path",ticktype = "detailed" )

# Add the gradient descent path
points3D(m_path, c_path, z = sapply(1:iterations, function(i) mse(m_path[i], c_path[i], x, y)), 
         col = "red", pch = 20, add = TRUE, cex = 0.5)

```

Exercise Questions

1.  Experiment with the Learning Rate Try changing the value of alpha (learning rate) to see its effect on convergence. Question: What happens if alpha is too high? Does the MSE converge smoothly, or does it oscillate? Question: What happens if alpha is too low? How does it affect the number of iterations required to reach a stable value?
2.  Change the Initial Guess Try different initial values for m. For example, use m = 5 or m = -3. Question: Does the algorithm converge to the same solution? How does the initial value of m affect the convergence?
3.  Extend to Optimize Both m and c Modify the code to perform gradient descent on both the slope (m) and intercept (c). Hint: You'll need to add a derivative function for c and update c in each iteration as well. Question: How does optimizing both m and c simultaneously compare to optimizing only m?
