{"title":"(4) Gradient Descent","markdown":{"headingText":"(4) Gradient Descent","containsRefs":false,"markdown":"\n```{r}\n#| message: false\nlibrary(tidyverse)\nlibrary(plot3D)\n```\n\n\n\nGradient descent is a foundational **optimization** technique widely used in machine learning to find the **minimum** of a function. [The core idea is to iteratively adjust variables in the opposite direction of the gradient (slope) to minimize the function’s output]{style=\"color:blue;\"}.\n\n## The Gradient Descent Formula\n\nThe general update formula for gradient descent is:\n\n$$\nx_{n+1} = x_n - \\alpha f'(x_n) \n$$\n\nwhere:\n\n-   $x_n$ is the current guess\n-   $f'(x_n)$ is the gradient at $x_n$\n-   $\\alpha$ is the learning rate (a small positive constant that controls the step size)\n\nThe idea is that the steeper the slope, the larger the update, moving us closer to the minimum.\n\n## Single-Variable Gradient Descent\n\nLet’s replicate the slides seen in class and minimize a single-variable function, $f(x) = x^2$. Imagine we start with an initial guess that the minimum is at $x = -4$ (although we know this is not the true minimum, from class we have seen this happens at $x = 0$). We will iteratively improve this guess by calculating the derivative (gradient) and adjusting the guess.\n\n### Understanding the Derivative's Role\n\nIn gradient descent, the derivative (or gradient) tells us the slope of the function at any given point. Here’s the intuition:\n\n-   *If the derivative is positive*: The function is sloping upwards, so we should move \"downhill\" by decreasing our guess.\n\n-   *If the derivative is negative*: The function is sloping downwards, so we should move \"downhill\" by increasing our guess.\n\nThis approach ensures that we move towards the minimum at each step.\n\n### Example: Minimizing $f(x) = x^2$\n\nUsing function $f(x) = x^2$, first we have to calculate the derivative of this function $f'(x) = 2x$\n\n```{r}\n#Define the function and its derivative \n\nf <- function(x) {\n  \n  x^2\n}\n\nf_prime <- function(x) {\n  \n  2* x\n  \n}\n```\n\nThis is how they look:\n\n```{r}\n\nlibrary(ggplot2)\n# Create a sequence of x values\nx_vals <- seq(-10, 10, length.out = 100)\n\n# Compute y values for both functions\ndata <- data.frame(\n  x = x_vals,\n  f_x = f(x_vals),\n  f_prime_x = f_prime(x_vals)\n)\n\nhead(data)\n\nlibrary(patchwork)\n\nA <- ggplot(data, aes(x = x)) +\n  geom_line(aes(y = f_x, color = \"f(x) = x^2\"), size = 1) +\n  #geom_line(aes(y = f_prime_x, color = \"f'(x) = 2x\"), size = 1) +\n  labs(title = \"Plot of f(x) = x^2 \",\n       x = \"x\",\n       y = \"f(x)\") +\n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  scale_color_manual(\"\", values = c(\"f(x) = x^2\" = \"blue\", \"f'(x) = 2x\" = \"red\")) +\n  theme_minimal()\n\nB <- ggplot(data, aes(x = x)) +\n  #geom_line(aes(y = f_x, color = \"f(x) = x^2\"), size = 1) +\n  geom_line(aes(y = f_prime_x, color = \"f'(x) = 2x\"), size = 1) +\n  labs(title = \"Plot of  f'(x) = 2x\",\n       x = \"x\",\n       y = \"f'(x)\") +\n  ylim(-20, 100) +  \n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  scale_color_manual(\"\", values = c(\"f(x) = x^2\" = \"blue\", \"f'(x) = 2x\" = \"red\")) +\n  theme_minimal()\n\nA + B\n\n```\n\n```{r}\n# Set initial values\n\nalpha <- 0.8 # Learning rate \nx <- -10 # Initial guess\nx_store <- NULL\n```\n\nAs previosuly explained, the general update formula for gradient descent is:\n\n$$\nx_{n+1} = x_n - \\alpha f'(x_n) \n$$\n\nAs you can see, this code iteratively adjusts our guess $x$ based on the gradient at each step, converging towards the minimum. To find the minimum of a function, gradient descent updates the current guess x_n by a step that depends on the gradient (slope) at x_n.\n\n```{r}\n# Gradient descent loop\n\nfor (i in 1:10) { \n  \n  gradient <- f_prime(x) \n  \n  \n  # Update parameters\n  x <- x - alpha * gradient\n\n  # Store values for plotting\n  x_store[i] <- x\n  \n  cat(\"Step\", i, \": x =\", x, \"f(x) =\", f(x), \"\\n\") \n  \n  }\n```\n\nThis code iteratively adjusts $x$ based on the gradient at each step, converging towards the minimum of f(x).\n\nPlotting it all together\n\n```{r}\n\nApproximations <- data.frame(x = x_store, y = f(x_store), dy = f_prime(x_store)) %>%\n  add_rownames()# Assign a \"darkening\" group\n\nApproximations$rowname <- as.numeric(Approximations$rowname )\n\nA <- ggplot(data, aes(x = x)) +\n  geom_line(aes(y = f_x), color = \"blue\", size = 1) +\n  labs(title = \"Plot of f(x) = x^2 \",\n       x = \"x\",\n       y = \"f(x)\") +\n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  geom_point(data = Approximations, aes(x = x, y = y, fill = rowname), size = 3,pch=21,colour = \"black\", show.legend = FALSE) +\n  scale_fill_gradient(low = \"yellow\", high = \"red\", na.value = NA) +\n  theme_minimal()\n\nB <- ggplot(data, aes(x = x)) +\n  geom_line(aes(y = f_prime_x),  color = \"blue\", size = 1) +\n  labs(title = \"Plot of  f'(x) = 2x\",\n       x = \"x\",\n       y = \"f'(x)\") +\n  ylim(-20, 100) +  \n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  geom_point(data = Approximations, aes(x = x, y = dy, fill = rowname), size = 3,pch=21,colour = \"black\", show.legend = FALSE) +\n  scale_fill_gradient(low = \"yellow\", high = \"red\", na.value = NA) +\n  theme_minimal()\n\nA + B\n\n\n```\n\n::: callout-note\n## Note\n\nA larger learning rate $\\alpha$ can make the steps too large, causing the algorithm to \"overshoot\" the minimum, while a smaller learning rate may result in slow convergence.\n:::\n\n## Your turn! \n\nUse gradient descent to minimize the following functions. For each function, start with different initial guesses and observe how the algorithm converges to a minimum.\n\n$$\nf(x) = x^2 + 3x + 5\n$$\n\n```{r}\n# Define the function and its derivative \n\nf <- function(x) {\n  x^2 + 3*x + 5\n  \n}\n  \nf_prime <- function(x) {\n  \n  2*x + 3\n  \n}\n```\n\nWhy not plot it?\n\n```{r}\n\n# Create a sequence of x values\nx_vals <- seq(-15, 15, length.out = 100)\n\n# Compute y values for both functions\ndata <- data.frame(\n  x = x_vals,\n  f_x = f(x_vals),\n  f_prime_x = f_prime(x_vals)\n)\n\nhead(data)\n\nlibrary(patchwork)\n\nA <- ggplot(data, aes(x = x)) +\n  geom_line(aes(y = f_x, color = \"f(x) =  x^2 + 3*x + 5\"), size = 1) +\n  #geom_line(aes(y = f_prime_x, color = \"f'(x) = 2x + 1\"), size = 1) +\n  labs(title = \"Plot of f(x) =  x^2 + 3*x + 5\",\n       x = \"x\",\n       y = \"f(x)\") +\n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  scale_color_manual(\"\", values = c(\"f(x) =  x^2 + 3*x + 5\" = \"blue\")) +\n  theme_minimal()\n\nB <- ggplot(data, aes(x = x)) +\n  #geom_line(aes(y = f_x, color = \"f(x) = x^2\"), size = 1) +\n  geom_line(aes(y = f_prime_x, color = \"f'(x) = 2*x + 3\"), size = 1) +\n  labs(title = \"Plot of  f'(x) = 2*x + 3\",\n       x = \"x\",\n       y = \"f'(x)\") +\n  ylim(-30, 100) +  \n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  scale_color_manual(\"\", values = c( \"f'(x) = 2*x + 3\" = \"red\")) +\n  theme_minimal()\n\nA + B\n```\n\n```{r}\n# Parameters\n\nalpha <- 0.01 \nx <- 2 # Initial guess\n```\n\n```{r}\n# Gradient descent loop\n\nfor (i in 1:10) { \n  \n  x <- x - alpha * f_prime(x) \n  \n  cat(\"Step\", i, \": x =\", x, \"f(x) =\", f(x), \"\\n\") \n  \n  }\n```\n\n## Part 3: Local vs Global Minima\n\nGradient descent may not always reach the global minimum, especially if the function has multiple minima. The algorithm might \"get stuck\" in a local minimum, particularly if the initial guess is close to one of these minimum.\n\nConsider the function $f(x) = x^4 + x^3 - 2x^2$, which has both local and global minima.\n\n```{r}\nf <- function(x) {\n  \n  x^4 + x^3 - 2*(x^2) \n}\n  \nf_prime <- function(x){\n  \n  4*(x^3) + 3*(x^2) - 4*x\n}\n```\n\nParameters\n\n```{r}\nalpha <- 0.01 \nx <- 1\nx_store <- NULL\n```\n\n```{r}\nfor (i in 1:10) { \n  \n  \n  x <- x - alpha *f_prime(x) \n  \n  x_store[i] <- x\n  \n  cat(\"Step\", i, \": x =\", x, \"f(x) =\", f(x), \"\\n\") \n  \n}\n```\n\n```{r}\n\nApproximations <- data.frame(x = x_store, y = f(x_store), dy = f_prime(x_store)) %>%\n  add_rownames()# Assign a \"darkening\" group)\n\nApproximations$rowname <- as.numeric(Approximations$rowname )\n\n# Create a sequence of x values\nx_vals <- seq(-15, 15, length.out = 100)\n\n# Compute y values for both functions\ndata <- data.frame(\n  x = x_vals,\n  f_x = f(x_vals),\n  f_prime_x = f_prime(x_vals)\n)\n\nhead(data)\n\nA_big <- ggplot(data, aes(x = x)) +\n  geom_line(aes(y = f_x), color = \"blue\", size = 1) +\n  labs(title = \"Plot of f(x) = x^4 + x^3 - 2*x^2  \",\n       x = \"x\",\n       y = \"f(x)\") +\n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  geom_point(data = Approximations, aes(x = x, y = y, fill = rowname), size = 3,pch=21,colour = \"black\", show.legend = FALSE) +\n  scale_fill_gradient(low = \"yellow\", high = \"red\", na.value = NA) +\n  theme_minimal()\n\n\n# Create a sequence of x values\nx_vals <- seq(-5, 5, length.out = 100)\n\n# Compute y values for both functions\ndata <- data.frame(\n  x = x_vals,\n  f_x = f(x_vals),\n  f_prime_x = f_prime(x_vals)\n)\n\nhead(data)\n\nA <- ggplot(data, aes(x = x)) +\n  geom_line(aes(y = f_x), color = \"blue\", size = 1) +\n  labs(title = \"Plot of f(x) = x^4 + x^3 - 2*x^2  \",\n       x = \"x\",\n       y = \"f(x)\") +\n   ylim(-5, 5) +  \n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  geom_point(data = Approximations, aes(x = x, y = y, fill = rowname), size = 3,pch=21,colour = \"black\", show.legend = FALSE) +\n  scale_fill_gradient(low = \"yellow\", high = \"red\", na.value = NA) +\n  theme_minimal()\n\nB <- ggplot(data, aes(x = x)) +\n  geom_line(aes(y = f_prime_x),  color = \"blue\", size = 1) +\n  labs(title = \"Plot of  f'(x) = 4*x^3 + 3*x^2 - 4*x\",\n       x = \"x\",\n       y = \"f'(x)\") +\n  ylim(-20, 90) +  \n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  geom_point(data = Approximations, aes(x = x, y = dy, fill = rowname), size = 3,pch=21,colour = \"black\", show.legend = FALSE) +\n  scale_fill_gradient(low = \"yellow\", high = \"red\", na.value = NA) +\n  theme_minimal()\n\n(A_big | A) \n\n(A | B )\n```\n\nWe see this function has 2 minimums! One is a local minimim and the other the global minimum. Depending on where we start (intialization point) we will end up in one or the other.\n\nExercise! Try different initial guesses, record which initial guess leads to global minimum.\n\nParameters\n\n```{r}\nalpha <- 0.03\nx <- -0.5\nx_store <- NULL\nnumber_iterations <- 100\n```\n\n```{r}\nfor (i in 1:number_iterations) { \n  \n  \n  x <- x - alpha *f_prime(x) \n  \n  x_store[i] <- x\n  \n  cat(\"Step\", i, \": x =\", x, \"f(x) =\", f(x), \"\\n\") \n  \n}\n```\n\n```{r}\n\n\n\nApproximations <- data.frame(x = x_store, y = f(x_store), dy = f_prime(x_store)) %>%\n  add_rownames()# Assign a \"darkening\" group)\n\nApproximations$rowname <- as.numeric(Approximations$rowname )\n\n# Create a sequence of x values\nx_vals <- seq(-15, 15, length.out = 100)\n\n# Compute y values for both functions\ndata <- data.frame(\n  x = x_vals,\n  f_x = f(x_vals),\n  f_prime_x = f_prime(x_vals)\n)\n\nhead(data)\n\nA_big <- ggplot(data, aes(x = x)) +\n  geom_line(aes(y = f_x), color = \"blue\", size = 1) +\n  labs(title = \"Plot of f(x) = x^4 + x^3 - 2*x^2  \",\n       x = \"x\",\n       y = \"f(x)\") +\n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  geom_point(data = Approximations, aes(x = x, y = y, fill = rowname), size = 3,pch=21,colour = \"black\", show.legend = FALSE) +\n  scale_fill_gradient(low = \"yellow\", high = \"red\", na.value = NA) +\n  theme_minimal()\n\n\n# Create a sequence of x values\nx_vals <- seq(-5, 5, length.out = 100)\n\n# Compute y values for both functions\ndata <- data.frame(\n  x = x_vals,\n  f_x = f(x_vals),\n  f_prime_x = f_prime(x_vals)\n)\n\nhead(data)\n\nA <- ggplot(data, aes(x = x)) +\n  geom_line(aes(y = f_x), color = \"blue\", size = 1) +\n  labs(title = \"Plot of f(x) = x^4 + x^3 - 2*x^2  \",\n       x = \"x\",\n       y = \"f(x)\") +\n   ylim(-5, 5) +  \n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  geom_point(data = Approximations, aes(x = x, y = y, fill = rowname), size = 3,pch=21,colour = \"black\", show.legend = FALSE) +\n  scale_fill_gradient(low = \"yellow\", high = \"red\", na.value = NA) +\n  theme_minimal()\n\nB <- ggplot(data, aes(x = x)) +\n  geom_line(aes(y = f_prime_x),  color = \"blue\", size = 1) +\n  labs(title = \"Plot of  f'(x) = 4*x^3 + 3*x^2 - 4*x\",\n       x = \"x\",\n       y = \"f'(x)\") +\n  ylim(-20, 90) +  \n  geom_hline(yintercept = 0, color = \"black\") +  # Add horizontal line at y = 0\n  geom_vline(xintercept = 0, color = \"black\") +\n  geom_point(data = Approximations, aes(x = x, y = dy, fill = rowname), size = 3,pch=21,colour = \"black\", show.legend = FALSE) +\n  scale_fill_gradient(low = \"yellow\", high = \"red\", na.value = NA) +\n  theme_minimal()\n\n(A_big | A) \n\n(A | B )\n```\n\nWhat happens at initial point x = 0? And if you increase the learning rate a lot? Does it mean it gets to the minimum faster? But which one? What is another parameter you can modify?..... ITERATIONS!\n\n\n```{r}\n#Try out any other modification!\n```\n\n\nAs you have seen:\n\nThe choice of learning rate $\\alpha$ is crucial:\n\n-   If $\\alpha$ too large, the algorithm might oscillate and fail to converge.\n\n-   If $\\alpha$ too slow, requiring more iterations.\n\nExample of high learning rate:\n\nSetting $\\alpha = 0.5$\n\n## Part 4: Multivariable Gradient Descent\n\nMultivariable gradient descent is an extension of the single-variable case. Instead of using a single derivative, we calculate the gradient vector, which consists of the partial derivatives of the function with respect to each variable.\n\nConsider the function:\n\n$$\nf(x, y) = xsin(y) + x^2\n$$\n\nThe gradient of this function is:\n\n$$\n\\nabla f(x, y) = \\left\\langle \\frac{\\partial f}{\\partial x}, \\frac{\\partial f}{\\partial y} \\right\\rangle = \\langle \\sin(y) + 2x, x \\cos(y) \\rangle\n$$\n\nLet's apply gradient descent starting from an initial guess of $\\vec{x} = (1, 2)$ with a learning rate of $\\alpha = 0.01$\n\n```{r}\n# Define the function and its partial derivatives \n\nf <- function(x, y) {\n  x* sin(y) + x^2 \n}\n  \nf_x <- function(x, y) {\n  \n  sin(y) + 2*x \n  \n}\n  \n\nf_y <- function(x, y){\n  \n  x*cos(y)\n\n}\n```\n\nAnother way to do it in R is using the function Deriv()\n\n```{r}\nlibrary(Deriv) \n\n\n# Define the function f(x, y) = x* sin(y) + x^2\n\nf <- function(x, y) { \n  x*sin(y) + x^2 \n  }\n\n# Compute the gradient symbolically (exact expressions)\n\ngrad_f <- Deriv(expression(x*sin(y) + x^2), c(\"x\", \"y\"))\n\nprint(grad_f)\n#expression(c(x = 2 * x + sin(y), y = x * cos(y))) Computes the partial derivatives for you!!!!!\n\ngradient <- function(x, y) { \n  \n  eval(grad_f) \n  }\n```\n\nAs you can see is the partial derivatives above written, directly calculated\n\n```{r}\n# Initial parameters\n\nalpha <- 0.01 # Learning rate \niterations <- 100 # Number of iterations \nx <- 1 # Initial guess for x \ny <- 2 # Initial guess for y\n\n# Store results for plotting\n\nresults <- data.frame(Iteration = 0, x = x, y = y, f_value = f(x, y))\n\n# Gradient descent loop\n```\n\n```{r}\n\nfor (i in 1:iterations) { \n  \n  grad <- gradient(x = x, y = y)\n  \n  # Evaluate gradient \n  x <- x - alpha* grad[1] \n  y <- y - alpha * grad[2] \n  results <- rbind(results, data.frame(Iteration = i, x = x, y = y, f_value = f(x, y))) \n  \n # would be the same as:\n  #x <- x - alpha*f_x(x, y) \n  #y <- y - alpha* f_y(x, y) \n  \n  \n  }\n\n# Display first few iterations\n\nhead(results)\n```\n\n```{r}\n#Generate grid data for 3D surface plot \n\nx_vals <- seq(-2, 2, length.out = 50) \ny_vals <- seq(-1, 3, length.out = 50) \nz_vals <- outer(x_vals, y_vals, Vectorize(f)) #evaluate x and y values in function f\n\n# 3D plot\n\npersp3D(x = x_vals, y = y_vals, z = z_vals, col = \"lightblue\", theta = 30, phi = 20, expand = 0.6, shade = 0.5, main = \"Gradient Descent Path on f(x, y) = x*sin(y) + x^2\", xlab = \"x\", ylab = \"y\", zlab = \"f(x, y)\")\n\n# Overlay gradient descent path\n\npoints3D(results$x, results$y, results$f_value, col = \"red\", pch = 19, add = TRUE)\nlines3D(results$x, results$y, results$f_value, col = \"red\", add = TRUE)\n```\nAs expected, the value of the function is being minimized at each iteration!\n\n```{r}\n# Plot the value of f(x, y) over iterations \n\nggplot(results, aes(x = Iteration, y = f_value)) + geom_line(color = \"blue\") + labs( title = \"Convergence of Gradient Descent on f(x, y) = x*sin(y) + x^2\", x = \"Iteration\", y = \"f(x, y)\" ) + theme_minimal()\n\n```\n\n## Final Remarks\n\nGradient descent is a versatile optimization technique, but it’s not without limitations:\n\n* It may converge to local minima rather than the global minimum. It is sensitive to the choice of learning rate and initial guess.\n\n* Variants of gradient descent, like stochastic gradient descent (SGD) and momentum-based methods, are often used to address these issues in large-scale machine learning tasks. Understanding and experimenting with gradient descent is crucial for developing an intuition about optimization in machine learning and algorithms. \n\n# Try it out with our own MSE, from the previous exercises\n\n```{r}\n\nlibrary(mlbench)\n\n# Load the dataset\ndata(\"PimaIndiansDiabetes\")\n\n# Select the first 80 rows and extract the variables\ndata_subset <- PimaIndiansDiabetes[1:80, ]\nx <- data_subset$age\ny <- data_subset$glucose\n\n```\n\n```{r}\n# Gradient descent parameters\nalpha <- 0.0001  # Learning rate\niterations <- 1000  # Number of iterations\nm <- -3  # Initial guess for slope\nc <- 55  # Initial guess for intercept\n\n# Lists to store m, c, and MSE values for plotting\nm_path <- numeric(iterations)\nc_path <- numeric(iterations)\nmse_history <- numeric(iterations)\n\n```\n\n\n\n\n```{r}\n# Define the MSE function\nmse <- function(m, c, x, y) {\n  \n  y_pred <- m * x + c\n  mean((y - y_pred)^2)\n  \n  #same thing: (1 / n) * sum((y - (m * x + c))^2)\n}\n\n# Define the gradients of MSE with respect to m and c\nmse_gradient_m <- function(m, c, x, y) {\n  -2 / length(y) * sum(x * (y - (m * x + c)))\n}\n\nmse_gradient_c <- function(m, c, x, y) {\n  -2 / length(y) * sum(y - (m * x + c))\n}\n\n#Remember can also apply the Deriv function \n\ngrad_f <- Deriv(expression((1 / n)* sum((y - (m * x + c))^2)), c(\"m\", \"c\"))\n\nprint(grad_f)\n    \n    \n```\nUnsure where the derivatives come from or how to calculate them?Go to the OLS_Derivation exercise. \n\nNow, lets perform gradient descent: \n```{r}\n# Perform gradient descent\nfor (i in 1:iterations) {\n  # Compute gradients\n  grad_m <- mse_gradient_m(m, c, x, y)\n  grad_c <- mse_gradient_c(m, c, x, y)\n  \n  # Update parameters\n  m <- m - alpha * grad_m\n  c <- c - alpha * grad_c\n  \n  # Store values for plotting\n  m_path[i] <- m\n  c_path[i] <- c\n  mse_history[i] <- mse(m, c, x, y)\n  \n  # Print progress every 100 iterations\n  if (i %% 100 == 0) {\n    cat(\"Iteration:\", i, \"Slope (m):\", m, \"Intercept (c):\", c, \"MSE:\", mse_history[i], \"\\n\")\n  }\n}\n\n```\n\nOptimized parameters:\n\n```{r}\n\npaste0(\"Slope:\" ,m)\npaste0(\"Slope:\" ,c)\n```\n\n\n```{r}\n# Plot the data points and the fitted line\nggplot(data_subset, aes(x = age, y = glucose)) +\n  geom_point() +\n  geom_abline(intercept = c, slope = m, color = \"blue\", size = 1) +\n  labs(title = \"Linear Fit using Gradient Descent\", x = \"Age\", y = \"Glucose\") +\n  theme_minimal()\n\n# Plot MSE over iterations\nmse_df <- data.frame(iteration = 1:iterations, MSE = mse_history)\nggplot(mse_df, aes(x = iteration, y = MSE)) +\n  geom_line(color = \"red\") +\n  labs(title = \"MSE over Iterations\", x = \"Iteration\", y = \"Mean Squared Error\") +\n  theme_minimal()\n\n```\n\n```{r}\n# Create a grid of values for m and c\nm_values <- seq(-5, 5, length.out = 50)\nc_values <- seq(0, 200, length.out = 50)\n\n# Initialize a matrix to store MSE values\nmse_matrix <- outer(m_values, c_values, Vectorize(function(m, c) mse(m, c, x, y)))\n\n# Plot the MSE surface\npersp3D(x = m_values, y = c_values, z = mse_matrix, \n        theta = 45, phi = 0, \n        xlab = \"Slope (m)\", ylab = \"Intercept (c)\", zlab = \"MSE\",\n        main = \"MSE Surface with Gradient Descent Path\",ticktype = \"detailed\" )\n\n# Add the gradient descent path\npoints3D(m_path, c_path, z = sapply(1:iterations, function(i) mse(m_path[i], c_path[i], x, y)), \n         col = \"red\", pch = 20, add = TRUE, cex = 0.5)\n\n```\n\nExercise Questions\n\n1.  Experiment with the Learning Rate Try changing the value of alpha (learning rate) to see its effect on convergence. Question: What happens if alpha is too high? Does the MSE converge smoothly, or does it oscillate? Question: What happens if alpha is too low? How does it affect the number of iterations required to reach a stable value?\n2.  Change the Initial Guess Try different initial values for m. For example, use m = 5 or m = -3. Question: Does the algorithm converge to the same solution? How does the initial value of m affect the convergence?\n3.  Extend to Optimize Both m and c Modify the code to perform gradient descent on both the slope (m) and intercept (c). Hint: You'll need to add a derivative function for c and update c in each iteration as well. Question: How does optimizing both m and c simultaneously compare to optimizing only m?\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"python":{"version":"r-reticulate"},"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"GradientDescent2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","editor":"visual","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}